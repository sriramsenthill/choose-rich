use crate::{
    deposit_monitor::{DepositMonitor, DepositMonitorConfig},
    server::AppState,
    store::{Store, User},
    wallet::WalletGenerator,
};
use sqlx::types::BigDecimal;
use std::{str::FromStr, sync::Arc, time::Duration};
use tokio::time;

#[cfg(test)]
mod tests {
    use super::*;

    async fn setup_test_db() -> Arc<Store> {
        let database_url = std::env::var("TEST_DATABASE_URL").unwrap_or_else(|_| {
            "postgresql://postgres:postgres@localhost:5432/choose_rich_test".to_string()
        });

        let pool = sqlx::postgres::PgPoolOptions::new()
            .max_connections(5)
            .connect(&database_url)
            .await
            .expect("Failed to connect to test database");

        // Clean up any existing data
        sqlx::query("DROP TABLE IF EXISTS game_transactions CASCADE")
            .execute(&pool)
            .await
            .ok();
        sqlx::query("DROP TABLE IF EXISTS users CASCADE")
            .execute(&pool)
            .await
            .ok();

        let store = Store::new(pool).await.expect("Failed to create store");
        Arc::new(store)
    }

    async fn create_test_user(store: &Store) -> User {
        let (evm_private_key, evm_address) = WalletGenerator::generate_evm_wallet()
            .await
            .expect("Failed to generate EVM wallet");

        let user = User::new(
            String::new(), // Will be generated by DB
            "test_user".to_string(),
            String::new(),
            evm_private_key,
            evm_address,
            Some("0x1234567890123456789012345678901234567890".to_string()),
            BigDecimal::from(0),
        );

        store
            .create_user(&user)
            .await
            .expect("Failed to create user")
    }

    #[tokio::test]
    async fn test_deposit_monitor_creation() {
        let store = setup_test_db().await;
        let config = DepositMonitorConfig::default();
        let monitor = DepositMonitor::new(store.clone(), config);

        let status = monitor.get_status().await;
        assert_eq!(status.get("is_running").unwrap(), &serde_json::json!(false));
        assert_eq!(
            status.get("simulation_mode").unwrap(),
            &serde_json::json!(true)
        );
    }

    #[tokio::test]
    async fn test_monitor_start_stop() {
        let store = setup_test_db().await;
        let config = DepositMonitorConfig {
            check_interval_secs: 1, // Fast interval for testing
            ..Default::default()
        };
        let monitor = DepositMonitor::new(store.clone(), config);

        // Start monitor
        monitor.start().await.expect("Failed to start monitor");

        // Give it a moment to start
        time::sleep(Duration::from_millis(100)).await;

        let status = monitor.get_status().await;
        assert_eq!(status.get("is_running").unwrap(), &serde_json::json!(true));

        // Stop monitor
        monitor.stop().await;

        // Give it a moment to stop
        time::sleep(Duration::from_millis(100)).await;
    }

    #[tokio::test]
    async fn test_force_simulate_deposit() {
        let store = setup_test_db().await;
        let user = create_test_user(&store).await;

        let config = DepositMonitorConfig::default();
        let monitor = DepositMonitor::new(store.clone(), config);

        let deposit_amount = BigDecimal::from_str("5.0").unwrap();
        let initial_balance = user.game_balance.clone();

        // Force simulate a deposit
        let result = monitor
            .force_simulate_deposit(&user.user_id, deposit_amount.clone())
            .await
            .expect("Failed to force simulate deposit");

        assert_eq!(result.user_id, user.user_id);
        assert_eq!(result.amount, deposit_amount);
        assert_eq!(result.new_balance, initial_balance + deposit_amount);
        assert!(!result.transaction_id.is_empty());

        // Verify balance was updated in database
        let updated_user = store
            .get_user_by_evm_addr(&user.evm_addr)
            .await
            .expect("Failed to get user")
            .expect("User not found");

        assert_eq!(updated_user.game_balance, initial_balance + deposit_amount);

        // Verify transaction was recorded
        let transactions = store
            .get_user_transactions(&user.user_id, Some(10))
            .await
            .expect("Failed to get transactions");

        assert_eq!(transactions.len(), 1);
        assert_eq!(transactions[0].transaction_type, "deposit");
        assert_eq!(transactions[0].amount, deposit_amount);
        assert!(
            transactions[0]
                .description
                .as_ref()
                .unwrap()
                .contains("blockchain")
        );
    }

    #[tokio::test]
    async fn test_multiple_deposits() {
        let store = setup_test_db().await;
        let user = create_test_user(&store).await;

        let config = DepositMonitorConfig::default();
        let monitor = DepositMonitor::new(store.clone(), config);

        let deposits = vec![
            BigDecimal::from_str("1.0").unwrap(),
            BigDecimal::from_str("2.5").unwrap(),
            BigDecimal::from_str("0.1").unwrap(),
        ];

        let mut expected_balance = user.game_balance.clone();

        for deposit_amount in deposits {
            let result = monitor
                .force_simulate_deposit(&user.user_id, deposit_amount.clone())
                .await
                .expect("Failed to force simulate deposit");

            expected_balance += deposit_amount.clone();
            assert_eq!(result.new_balance, expected_balance);
        }

        // Verify final balance
        let final_user = store
            .get_user_by_evm_addr(&user.evm_addr)
            .await
            .expect("Failed to get user")
            .expect("User not found");

        assert_eq!(final_user.game_balance, expected_balance);

        // Verify all transactions were recorded
        let transactions = store
            .get_user_transactions(&user.user_id, Some(10))
            .await
            .expect("Failed to get transactions");

        assert_eq!(transactions.len(), 3);
        for transaction in transactions {
            assert_eq!(transaction.transaction_type, "deposit");
        }
    }

    #[tokio::test]
    async fn test_monitored_addresses_retrieval() {
        let store = setup_test_db().await;

        // Create multiple test users
        let users = vec![
            create_test_user(&store).await,
            create_test_user(&store).await,
            create_test_user(&store).await,
        ];

        let config = DepositMonitorConfig::default();
        let monitor = DepositMonitor::new(store.clone(), config);

        // Get monitored addresses (this is a private method, so we'll test via check_deposits)
        let result = monitor
            .trigger_manual_check()
            .await
            .expect("Failed to trigger manual check");

        // Since simulation is enabled and probability is low, we might not get deposits
        // But the check should complete without errors
        assert_eq!(result.failed_deposits.len(), 0);
    }

    #[tokio::test]
    async fn test_simulation_with_high_probability() {
        let store = setup_test_db().await;

        // Create test users
        let users = vec![
            create_test_user(&store).await,
            create_test_user(&store).await,
        ];

        let config = DepositMonitorConfig {
            simulation_probability: 1.0, // 100% chance to generate deposits
            check_interval_secs: 1,
            ..Default::default()
        };

        let monitor = DepositMonitor::new(store.clone(), config);

        // Trigger manual check - should generate deposits for all users
        let result = monitor
            .trigger_manual_check()
            .await
            .expect("Failed to trigger manual check");

        // With 100% probability, we should get some deposits
        assert!(result.processed_deposits.len() > 0);
        assert_eq!(result.failed_deposits.len(), 0);

        // Verify balances were updated
        for user in users {
            let updated_user = store
                .get_user_by_evm_addr(&user.evm_addr)
                .await
                .expect("Failed to get user")
                .expect("User not found");

            if updated_user.game_balance > user.game_balance {
                // This user got a deposit - verify transaction exists
                let transactions = store
                    .get_user_transactions(&user.user_id, Some(10))
                    .await
                    .expect("Failed to get transactions");

                assert!(transactions.len() > 0);
                assert_eq!(transactions[0].transaction_type, "deposit");
            }
        }
    }

    #[tokio::test]
    async fn test_monitor_status_tracking() {
        let store = setup_test_db().await;
        let user = create_test_user(&store).await;

        let config = DepositMonitorConfig::default();
        let monitor = DepositMonitor::new(store.clone(), config);

        // Initial status
        let initial_status = monitor.get_status().await;
        assert_eq!(
            initial_status.get("is_running").unwrap(),
            &serde_json::json!(false)
        );
        assert_eq!(
            initial_status.get("simulation_mode").unwrap(),
            &serde_json::json!(true)
        );
        assert_eq!(
            initial_status.get("monitored_addresses").unwrap(),
            &serde_json::json!(1)
        );

        // Start monitor and check status
        monitor.start().await.expect("Failed to start monitor");

        time::sleep(Duration::from_millis(100)).await;

        let running_status = monitor.get_status().await;
        assert_eq!(
            running_status.get("is_running").unwrap(),
            &serde_json::json!(true)
        );

        // Force a deposit and check status changes
        let deposit_amount = BigDecimal::from_str("10.0").unwrap();
        monitor
            .force_simulate_deposit(&user.user_id, deposit_amount)
            .await
            .expect("Failed to force simulate deposit");

        let final_status = monitor.get_status().await;
        assert!(
            final_status
                .get("processed_transactions")
                .unwrap()
                .as_u64()
                .unwrap()
                > 0
        );

        monitor.stop().await;
    }

    #[tokio::test]
    async fn test_deposit_with_invalid_user() {
        let store = setup_test_db().await;

        let config = DepositMonitorConfig::default();
        let monitor = DepositMonitor::new(store.clone(), config);

        let deposit_amount = BigDecimal::from_str("5.0").unwrap();
        let invalid_user_id = "invalid-user-id";

        // This should fail because user doesn't exist
        let result = monitor
            .force_simulate_deposit(invalid_user_id, deposit_amount)
            .await;

        assert!(result.is_err());
    }

    #[tokio::test]
    async fn test_concurrent_deposits() {
        let store = setup_test_db().await;
        let user = create_test_user(&store).await;

        let config = DepositMonitorConfig::default();
        let monitor = Arc::new(DepositMonitor::new(store.clone(), config));

        let mut handles = vec![];

        // Simulate concurrent deposits
        for i in 0..5 {
            let monitor_clone = monitor.clone();
            let user_id = user.user_id.clone();
            let amount = BigDecimal::from_str(&format!("{}.0", i + 1)).unwrap();

            let handle = tokio::spawn(async move {
                monitor_clone.force_simulate_deposit(&user_id, amount).await
            });

            handles.push(handle);
        }

        // Wait for all deposits to complete
        let mut successful_deposits = 0;
        for handle in handles {
            match handle.await.expect("Task panicked") {
                Ok(_) => successful_deposits += 1,
                Err(e) => eprintln!("Deposit failed: {}", e),
            }
        }

        assert_eq!(successful_deposits, 5);

        // Verify final balance
        let final_user = store
            .get_user_by_evm_addr(&user.evm_addr)
            .await
            .expect("Failed to get user")
            .expect("User not found");

        // Should be sum of 1+2+3+4+5 = 15
        let expected_balance = user.game_balance.clone() + BigDecimal::from_str("15.0").unwrap();
        assert_eq!(final_user.game_balance, expected_balance);

        // Verify all transactions were recorded
        let transactions = store
            .get_user_transactions(&user.user_id, Some(10))
            .await
            .expect("Failed to get transactions");

        assert_eq!(transactions.len(), 5);
    }

    #[tokio::test]
    async fn test_deposit_monitor_integration_with_app_state() {
        let store = setup_test_db().await;
        let user = create_test_user(&store).await;

        // Create app state (similar to how it's done in main.rs)
        let sessions = Arc::new(moka::future::Cache::builder().build());
        let app_state = AppState::new(sessions, store.clone(), "test-secret".to_string());

        let config = DepositMonitorConfig {
            check_interval_secs: 1,
            simulation_probability: 0.5, // 50% chance
            ..Default::default()
        };

        let monitor = DepositMonitor::new(store.clone(), config);

        // Start monitor
        monitor.start().await.expect("Failed to start monitor");

        // Let it run for a few cycles
        time::sleep(Duration::from_secs(3)).await;

        // Check if any deposits were processed
        let final_user = store
            .get_user_by_evm_addr(&user.evm_addr)
            .await
            .expect("Failed to get user")
            .expect("User not found");

        // With 50% probability over 3 seconds, we might get deposits
        // This test verifies integration doesn't crash
        let transactions = store
            .get_user_transactions(&user.user_id, Some(10))
            .await
            .expect("Failed to get transactions");

        // Stop monitor
        monitor.stop().await;

        println!("Final balance: {}", final_user.game_balance);
        println!("Transactions count: {}", transactions.len());

        // Test passes if we get here without errors
        assert!(true);
    }

    #[tokio::test]
    async fn test_deposit_amounts_precision() {
        let store = setup_test_db().await;
        let user = create_test_user(&store).await;

        let config = DepositMonitorConfig::default();
        let monitor = DepositMonitor::new(store.clone(), config);

        // Test various precision amounts
        let test_amounts = vec!["0.001", "0.123456789", "1.50", "999.999999", "0.000001"];

        for amount_str in test_amounts {
            let deposit_amount = BigDecimal::from_str(amount_str).unwrap();
            let result = monitor
                .force_simulate_deposit(&user.user_id, deposit_amount.clone())
                .await
                .expect("Failed to force simulate deposit");

            assert_eq!(result.amount, deposit_amount);

            // Verify transaction was recorded with correct precision
            let transactions = store
                .get_user_transactions(&user.user_id, Some(1))
                .await
                .expect("Failed to get transactions");

            assert_eq!(transactions[0].amount, deposit_amount);
        }
    }

    #[tokio::test]
    async fn test_deposit_transaction_descriptions() {
        let store = setup_test_db().await;
        let user = create_test_user(&store).await;

        let config = DepositMonitorConfig::default();
        let monitor = DepositMonitor::new(store.clone(), config);

        let deposit_amount = BigDecimal::from_str("10.0").unwrap();
        let result = monitor
            .force_simulate_deposit(&user.user_id, deposit_amount)
            .await
            .expect("Failed to force simulate deposit");

        // Verify transaction description contains blockchain info
        let transactions = store
            .get_user_transactions(&user.user_id, Some(1))
            .await
            .expect("Failed to get transactions");

        let description = transactions[0].description.as_ref().unwrap();
        assert!(description.contains("Deposit from blockchain"));
        assert!(description.contains("tx:"));
        assert!(description.contains("0x")); // Should contain transaction hash
    }
}
