use crate::store::{Store, User};
use alloy::signers::local::LocalSigner;
use garden::api::primitives::{ApiResult, Response};
use serde::{Deserialize, Serialize};
use sqlx::types::BigDecimal;

// Request struct for wallet connection
#[derive(Deserialize)]
pub struct WalletConnectionRequest {
    pub wallet_address: String,
}

// Response struct for wallet connection
#[derive(Serialize)]
pub struct WalletConnectionResponse {
    pub user_id: String,
    pub game_private_key: String,
    pub game_public_key: String,
    pub game_evm_address: String,
    pub is_new_user: bool,
}

// Wallet generation utilities
pub struct WalletGenerator;

impl WalletGenerator {


    // Generate a new Ethereum keypair and address
    pub async fn generate_evm_wallet() -> Result<(String, String), Box<dyn std::error::Error>> {
        let signer = LocalSigner::random();
        let private_key = format!("0x{:x}", signer.credential().to_bytes());
        let address = signer.address();

        Ok((private_key, format!("0x{:x}", address)))
    }
}

// Wallet connection handler
pub async fn connect_wallet(
    wallet_address: String,
    store: &Store,
) -> ApiResult<WalletConnectionResponse> {
    // Check if user already exists with this wallet address
    let existing_user = store.get_user_by_wallet_addr(&wallet_address).await
        .map_err(|e| garden::api::internal_error(&format!("Database error: {}", e)))?;

    if let Some(user) = existing_user {
        // User already exists, return existing game wallet info
        let user_id = user.user_id.clone();
        return Ok(Response::ok(WalletConnectionResponse {
            user_id: user_id.clone(),
            game_private_key: user.pk.clone(),
            game_public_key: user_id.clone(), // Using user_id as public key for now
            game_evm_address: user.evm_addr.clone(),
            is_new_user: false,
        }));
    }



    let (evm_private_key, evm_address) = WalletGenerator::generate_evm_wallet().await
        .map_err(|e| garden::api::internal_error(&format!("Failed to generate EVM wallet: {}", e)))?;

    // Create new user record
    let safe_address_suffix = if wallet_address.len() >= 8 {
        wallet_address[..8].to_string()
    } else {
        wallet_address.clone()
    };
    
    let new_user = User::new(
        String::new(), // user_id will be generated by database
        format!("user_{}", safe_address_suffix), // username
        String::new(), // password (not needed for wallet users)
        evm_private_key, // pk (game private key)
        evm_address, // evm_addr (game EVM address)
        Some(wallet_address.clone()), // original_wallet_addr (the wallet they connected with)
        BigDecimal::from(0), // initial game balance
    );

    let created_user = store.create_user(&new_user).await
        .map_err(|e| garden::api::internal_error(&format!("Failed to create user: {}", e)))?;

    let user_id = created_user.user_id.clone();
    Ok(Response::ok(WalletConnectionResponse {
        user_id: user_id.clone(),
        game_private_key: created_user.pk.clone(),
        game_public_key: user_id.clone(),
        game_evm_address: created_user.evm_addr.clone(),
        is_new_user: true,
    }))
}

#[cfg(test)]
mod tests {
    use super::*;


    #[tokio::test]
    async fn test_generate_evm_wallet() {
        let result = WalletGenerator::generate_evm_wallet().await;
        assert!(result.is_ok());
        let (private_key, address) = result.unwrap();
        assert!(private_key.starts_with("0x"));
        assert!(address.starts_with("0x"));
        println!("Generated EVM address: {}", address);
    }
}
